using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Tyr.SourceGen
{
    [Generator]
    public class ConfigurableGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all classes with the Configurable attribute
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsPotentiallyConfigurableClass(s),
                    transform: static (ctx, _) => GetConfigurableClassIfValid(ctx))
                .Where(static m => m is not null)!;

            // Register source output action
            context.RegisterSourceOutput(classDeclarations, static (spc, classDeclaration) =>
                GeneratePartialClass(spc, classDeclaration));
        }

        private static bool IsPotentiallyConfigurableClass(SyntaxNode node)
        {
            // Quick check to filter out non-class declarations
            return node is ClassDeclarationSyntax classDecl &&
                   classDecl.AttributeLists.Count > 0;
        }

        private static ClassDeclarationSyntax? GetConfigurableClassIfValid(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;

            // Check if any attribute is named 'Configurable' or 'ConfigurableAttribute'
            foreach (var attributeList in classDeclaration.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    string attributeName = attribute.Name.ToString();
                    if (attributeName is "Configurable" or "ConfigurableAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }

            return null;
        }

        private static void GeneratePartialClass(SourceProductionContext context,
            ClassDeclarationSyntax classDeclaration)
        {
            // Get the class name
            string className = classDeclaration.Identifier.ToString();

            // Get namespace (handling both regular and file-scoped namespaces)
            string namespaceName = GetNamespace(classDeclaration);

            // Generate the partial class with the Configurable field
            string source = GeneratePartialClassSource(namespaceName, className);

            // Add the source file
            context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
        {
            // Try to find a namespace declaration
            SyntaxNode? parent = classDeclaration.Parent;
            while (parent != null)
            {
                if (parent is NamespaceDeclarationSyntax namespaceDeclaration)
                {
                    return namespaceDeclaration.Name.ToString();
                }

                if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespace)
                {
                    return fileScopedNamespace.Name.ToString();
                }

                parent = parent.Parent;
            }

            // If no namespace found, return empty string
            return string.Empty;
        }

        private static string GeneratePartialClassSource(string namespaceName, string className)
        {
            return $$"""
                     // <auto-generated/>
                     #nullable enable

                     namespace {{namespaceName}}
                     {
                         public partial class {{className}}
                         {
                             private static Tyr.Common.Config.Configurable? _configurable;
                             private static Tyr.Common.Config.Configurable Configurable => _configurable ??= Tyr.Common.Config.Registry.Get(typeof({{className}}));
                         }
                     }
                     """;
        }
    }
}